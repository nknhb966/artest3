<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <title>WebXR 3D Dropdown</title>
    <style>
      body { margin: 0; overflow: hidden; }
      canvas { display: block; }
    </style>
  </head>

<script type="importmap">
{
  "imports": {
    "three": "https://code4fukui.github.io/three.js/build/three.module.js",
    "three/addons/": "https://code4fukui.github.io/three.js/examples/jsm/"
  }
}
</script>

  <body>
    <script type="module">
      import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js';
      import { GLTFLoader } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/loaders/GLTFLoader.js';
      import { ARButton } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/webxr/ARButton.js';

      let camera, scene, renderer;
      let controller;
      let dropdownButton;
      let dropdownItems = [];
      let currentModel = null;
      const loader = new GLTFLoader();

      init();
      animate();

      function init() {
        scene = new THREE.Scene();

        camera = new THREE.PerspectiveCamera(
          70,
          window.innerWidth / window.innerHeight,
          0.01,
          20
        );

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.xr.enabled = true;
        document.body.appendChild(renderer.domElement);
        document.body.appendChild(ARButton.createButton(renderer));

        // ドロップダウンボタン（青）
        dropdownButton = createButton('▼ モデル選択', 0x0077ff);
        dropdownButton.position.set(0, 0, -0.5);
        scene.add(dropdownButton);

        // ドロップダウン項目（非表示から開始）
        const itemNames = ['modelA.glb', 'modelB.glb'];
        for (let i = 0; i < itemNames.length; i++) {
          const item = createButton(itemNames[i], 0x444444);
          item.position.set(0, -(i + 1) * 0.12, -0.5);
          item.visible = false;
          scene.add(item);
          dropdownItems.push({ mesh: item, name: itemNames[i] });
        }

        // コントローラーの取得（タップ用）
        controller = renderer.xr.getController(0);
        controller.addEventListener('select', onSelect);
        scene.add(controller);
      }

      function createButton(text, color) {
        const canvas = document.createElement('canvas');
        canvas.width = 256;
        canvas.height = 64;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = 'white';
        ctx.font = '24px sans-serif';
        ctx.fillText(text, 10, 40);

        const texture = new THREE.CanvasTexture(canvas);
        const material = new THREE.MeshBasicMaterial({ map: texture, color });
        const geometry = new THREE.PlaneGeometry(0.4, 0.1);
        return new THREE.Mesh(geometry, material);
      }

      function onSelect() {
        const tempMatrix = new THREE.Matrix4();
        tempMatrix.identity().extractRotation(controller.matrixWorld);

        const raycaster = new THREE.Raycaster();
        raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
        raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);

        const intersects = raycaster.intersectObjects(
          [dropdownButton, ...dropdownItems.map(item => item.mesh)]
        );

        if (intersects.length > 0) {
          const selected = intersects[0].object;

          if (selected === dropdownButton) {
            // 項目の表示切り替え
            dropdownItems.forEach(item => {
              item.mesh.visible = !item.mesh.visible;
            });
          } else {
            // どれかの項目が選ばれた
            const selectedItem = dropdownItems.find(i => i.mesh === selected);
            if (selectedItem) {
              loadModel(selectedItem.name);
              dropdownItems.forEach(item => item.mesh.visible = false);
            }
          }
        }
      }

      function loadModel(path) {
        if (currentModel) {
          scene.remove(currentModel);
        }

        loader.load(path, gltf => {
          currentModel = gltf.scene;
          currentModel.position.set(0, -0.2, -0.5);
          scene.add(currentModel);
        });
      }

      function animate() {
        renderer.setAnimationLoop(() => {
          renderer.render(scene, camera);
        });
      }
    </script>
  </body>
</html>
